/*
Copyright (c) 2020, Charter Communications Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. Neither the name of the Charter Communications Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Charter Communications Inc. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef IOTM_PLUG_EVENT_H_INCLUDED
#define IOTM_PLUG_EVENT_H_INCLUDED

/**
 * @file iotm_plug_event.h
 *
 * @brief a plugin constructs an event then emits to iotm
 *
 * Plugin events are generated by a plugin and passed to the manager. A plugin
 * may get a freshly allocated event, add any params it has identified for the
 * event.
 *
 */

#define MAX_NAME 1024
#include "ds_tree.h"
#include "ds_list.h"
#include "log.h"         /* Logging routines */
#include "iotm_list.h"

struct plugin_event_t;

/**
 * @brief passed to a plugin, allows for allocating a new event to construct
 *
 * @param[out] event  loads address of new event
 *
 * @return 0 loaded address into param
 */
struct plugin_event_t *plugin_event_new();

/**
 * @brief helper that can be used by plugins, free an event that has been used
 *
 * @param self  event to free memory for
 */
void plugin_event_free(struct plugin_event_t *self);


/**
 * @brief helper for plugin to add a parameter to an iot event. 
 *
 * @note this will either create a new tree node, or append to an already
 * existing node in a list.
 *
 * example use: plugin pulls mac out of IoT event, adds it with key 'mac' to
 * the event
 *
 * @param key    list that this will be inserted into
 * @param param  parameter to push onto the list  
 */
int plugin_event_add(struct plugin_event_t *event,
        char *key,
        struct iotm_value_t *param);

/**
 * @brief allows a plugin to insert a parameter just as a string
 *
 * @note behaves in the same manner as add_param
 *
 * @param key    list that this will be inserted into
 * @param val    value to store, many to one relationship between keys and
 * values
 */
int plugin_event_add_str(struct plugin_event_t *event,
        char *key,
        char *val);

/**
 * @brief add a parameter of a specific type as a parameter
 *
 * @param self   event to add parameter to
 * @param key    key for parameter being added, i.e. 'UUID'
 * @param type   type of parameter being added (UINT16, etc.)
 * @param val    should be castable to type
 *
 * @return 0     added parameter to event
 * @return -1    failed to add parameter to event
 */
int plugin_event_add_type(
		struct plugin_event_t *self,
        char *key,
		int type,
        void *val);

/**
 * @brief get a parameter list as it's stored in an event.
 *
 * @note parameters are stored as list nodes in a red black tree, this allows
 * for a single key "serv_uuid" to map to a list of multiple elements when
 * necessary.
 *
 * @param event  event that plugin is building to pass to IoTM
 * @param key    name of parameter 
 *
 * @return NULL coudlnt' find event
 * @return list  list matching key
 */
struct iotm_list_t *plugin_event_get_list(struct plugin_event_t *event, char *key);

/**
 * @brief get a single node from a list, this will be the last node inserted
 *
 * @note if node doesn't exist this will allocate a node
 *
 * @param event  event that contains parameters
 * @param key    key that parameter is stored under
 */
struct iotm_value_t *plugin_event_get(struct plugin_event_t *event, char *key);

/**
 * @brief find param in list
 *
 * @return NULL if param not found
 */
struct iotm_list_t *plugin_event_find(struct plugin_event_t *self, char *key);


/**
 * @brief methods provided to plugin for interfacing with event
 *
 * @note a plugin will generate a new event using these methods, and then emit
 * the event for routing to the IoT Manager.
 */
struct event_ops_t
{
	void(*plugin_event_free)(struct plugin_event_t *); /**< plugin should free an event after it has been emitted to the manager */

	int(*add_param)(struct plugin_event_t *,
        char *,
        struct iotm_value_t *); /**< plugin may add parameters it has parsed out of the IoT event */

    int (*add_param_str)(struct plugin_event_t *event,
            char *key,
            char *val); /**< a plugin may add a parameter as a string and it will be added to the list */

    int (*add_param_type)(struct plugin_event_t *event,
            char *key,
			int type,
            void *val); /**< a plugin may add a parameter as a string and it will be added to the list */

    struct iotm_list_t *(*find)(struct plugin_event_t *self, char *key); /**< find a param */
};

/**
 * @brief contains type of IoT event and the data of the event
 *
 * @note an example of the param list would be the key 'serv_uuid' and the list
 * ['firstuuid', 'seconduuid', 'thirduuid']
 *
 * This is a FILO queue
 *
 * These can be accessed either through the get_single where it will retrieve
 * the last event, or through the foreach method provided by the list.
 */
struct plugin_event_t {
    int type; /**< enum for decoding union */
    bool initialized; /**< says whether members have been properly initialized */
	struct iotm_tree_t *params; /**< storage of param lists, key maps to set */
    char name[MAX_NAME]; /**< name of the event, map to ovsdb values */
	struct event_ops_t ops; /**< operations in event provided to plugin */
} plugin_event_t;


#endif // IOTM_PLUG_EVENT_H_INCLUDED */
