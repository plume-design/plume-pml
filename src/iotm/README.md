# Intro

The goals of the OpenSync IoT architecture are to enable 3rd parties to develop
features and applications on top of hardware running OpenSync. These applications
should follow the OpenSync design patterns where possible, meaning integrations
and features should be built in the cloud and expressed through rules and
configurations on the hardware. Some exceptions may need to break this rule, such
as for a local SmartThings integration.

This architecture proposes that any IoT application may be built by a series of
rules instructing the Central Application in it's behavior. The design of the
rules is to reflect how an application would write a callback ba sed interaction
with an IoT device. This allows the application to define through rules every
stage of interaction, through first reception of a packet from an iot device to
it's end state configuration. In addition, when a rule is installed that
specify an interaction upon connection, this rule also runs on any connected
devices. This allows for rules to be installed that say: 'when connected, the
light should be in the 'on' state'.

## Doxygen

The doxygen for this project can be generated by running the command:

```
doxygen doxygen/Doxyfile
```

## Components

### IoT Manager

This manager is an orchestrator for events. It is configured by OVSDB tables to
configure the routing of events between plugins, as well as what plugins are
loaded. The manager keeps track of all rules from the table `IOT_Rule_Config`,
all plugins are loaded with the table `IOT_Manager_Config`, and tags may be
loaded into the manager using the `Openflow_Tag` table. Updates to rules are
sent to any relevant loaded plugins. The plugin may 'emit' an event to the IoT
manager, it's the responsibility of the manager to find which rules match the
event, and then route corresponding commands to any plugins dictated by the
rule.

### Plugins

Plugins are developed to extend the protocols that the IoT manager may interact
with, provide cloud updates, or allow for on-the-device custom implementations.
A plugin 'subscribes' to IoT events through the rules that are loaded for it.
Once the plugin recieves an event, it may send it to a target layer call to
interface with the IoT radios, or may load it into a message and route it to
the cloud. A plugin may also 'emit' an event, this is most often done when a
response is recieved from an IoT radio through the target layer. Any event that
is emitted by the plugin will filter through the rules within the manager and
be dispatched accordingly.

### Shared Function Pointers

The IoT manager keeps track of a 'session' struct for each plugin. This struct
has information such as the plugin configurations that are stored in OVSDB, the
events that are loaded, and also contains relevant function pointers. These
are split into methods defined by the plugin and methods provided by the
manager. For example, when an event is routed to a plugin based off a rule set,
the manager will call the sessions session->ops.handler() method while passing
the command. A complete list of the shared function pointers can be viewed in
the `iotm_session.h` Doxygen.

### OVSDB Tables

The IoT manager, is informed by two OVSDB tables: IOT_Manager_Config and
IOT_Rule_Config. The manager configuration informs the manager what plugins
should load, the rule config stores all rules that should apply to the system.
The Plume OVSSCHEMA file needs to be updated to know about the rules, this can
be added by running the patch in `./patches/add_rule_tables.diff` with the
following command:

```
patch -Np1 -i ./patches/add_rule_tables.diff
```

Below are example rules for each table:

#### IOT_Manager_Config example

```
ovsh U IOT_Manager_Config -w handler=="dev_ble_default" \
    handler:="dev_ble_default" \
    plugin:="/usr/plume/lib/libiotm_ble.so" \
    other_config:='["map",[["dso_init","iotm_ble_handler_init"]]]' 
```

#### IOT_Manager_Config example

```
ovsh U IOT_Rule_Config -w name=="log_adverts_pulseox" \
    name:="log_adverts_pulseox" \
    event:="ble_advertised" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_example_plugin","ble_advertised"]]]'
```

## Files

### Core IoTM Logic

| File | Description |
| ----- | ---------- |
| iotm_main.c | entrypoint |
| iotm_router.c | recieve event from plugin, check rules, send commands |

### OVSDB to data structures with helpers

| File | Description |
| ---- | ---------- |
| iotm_ovsdb.c | bind to all OVSDB tables |
| iotm_event.c | encapsulates groupings of rules as events |
| iotm_rule.c | maps to IOT_Rule_Config |
| iotm_tag.c | tree containing Openflow_Tags, apis for string->tag conversion |
| iotm_service.c | maps to IOT_Manager_Config |
| iotm_ev.c | sets up event loop for manager and plugin |

### Shared between IoTM and Plugins

| File | Description |
| ----- | ---------- |
| iotm_session.c | container for all data shared with plugin |
| iotm_data_types.c | conversion utilities from string -> types |
| iotm_plug_command.c | iotm constructs a command, then sends to a plugin |
| iotm_plug_event.c | a plugin constructs an event then emits to iotm |
| iotm_tl.c | allows plugins to namespace out target layer contexts |

### Data structures

| File | Description |
| ----- | ---------- |
| iotm_list.c | list that stores key/value or allows custom data |
| iotm_tree.c | tree api, key collisions build iotm_list |

## Example Rules

Here are some OVSDB rules to demonstrate different IoT device interactions

### Logging all BLE advertise packets

```bash
ovsh U IOT_Rule_Config -w name=="dev_log_adverts" \
    name:="dev_log_adverts" \
    event:="ble_advertised" \
    filter:='["map",[["mac","*"]]]' \
    actions:='["map",[["dev_example_plugin","ble_advertised"]]]' \
```

### Pairing with a blood pressure cuff, getting a measurement

```bash
# Device Rules
ovsh U IOT_Rule_Config -w name=="connect_to_bp_cuff" \
    name:="connect_to_bp_cuff" \
    event:="ble_advertised" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_ble_default","ble_connect_device"]]]' \

ovsh U IOT_Rule_Config -w name=="dev_discover_services" \
    name:="dev_discover_services" \
    event:="ble_connected" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_ble_default","ble_discover_services"]]]' \

ovsh U IOT_Rule_Config -w name=="dev_discover_characteristics" \
    name:="dev_discover_characteristics" \
    event:="ble_serv_discovered" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_ble_default","ble_discover_characteristics"]]]' \

ovsh U IOT_Rule_Config -w name=="subscribe_char_bp" \
    name:="subscribe_char_bp" \
    event:="ble_char_discovered" \
    filter:='["map",[["mac","${dev_ble_mac}"],\
    ["char_uuid", "00002A35-0000-1000-8000-00805F9B34FB"]]]' \
    actions:='["map",[["dev_ble_default",\
    "ble_enable_characteristic_notifications"]]]' \

ovsh U IOT_Rule_Config -w name=="read_battery_level_bp" \
    name:="read_battery_level_bp" \
    event:="ble_char_discovered" \
    filter:='["map",[["mac","${dev_ble_mac}"],\
    ["char_uuid", "00002A19-0000-1000-8000-00805F9B34FB"]]]' \
    actions:='["map",[["dev_ble_default","ble_read_characteristic"]]]' \
```

### Enabling notifications for a pulse oximiter

```bash
ovsh U IOT_Rule_Config -w name=="log_adverts_pulseox" \
    name:="log_adverts_pulseox" \
    event:="ble_advertised" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_example_plugin","ble_advertised"]]]'

ovsh U IOT_Rule_Config -w name=="connect_to_pulseox" \
    name:="connect_to_pulseox" \
    event:="ble_advertised" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_ble_default","ble_connect_device"]]]'

ovsh U IOT_Rule_Config -w name=="discover_services_pulseox" \
    name:="discover_services_pulseox" \
    event:="ble_connected" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_ble_default","ble_discover_services"]]]'

ovsh U IOT_Rule_Config -w name=="discover_char_pulseox" \
    name:="discover_char_pulseox" \
    event:="ble_serv_discovered" \
    filter:='["map",[["mac","${dev_ble_mac}"]]]' \
    actions:='["map",[["dev_ble_default","ble_discover_characteristics"]]]'

ovsh U IOT_Rule_Config -w name=="dev_log_notifications" \
    name:="dev_log_notifications" \
    event:="ble_char_updated" \
    filter:='["map",[["mac","*"]]]' \
    actions:='["map",[["dev_example_plugin","ble_char_updated"]]]' \
```
